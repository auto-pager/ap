# आप -- ऑटो-पेजर

एपी एक शेल उपयोगिता है जो अन्य शेल कमांड के आउटपुट को स्वचालित रूप से इंटरैक्टिव पेज-फ्लिपिंग मोड में प्रवेश करने की अनुमति देती है।

एपी में दो भाग होते हैं, गो में लिखा गया एक बाइनरी प्रोग्राम जो कमांड के आउटपुट को कैप्चर करता है और पेज-फ़्लिपिंग का समर्थन करता है, और शेल स्क्रिप्ट का एक सेट जो उपयोगकर्ता द्वारा निर्दिष्ट कमांड की सूची के लिए एक ही नाम के साथ एक रैपर बनाता है।

रैप के बाद कमांड का उपयोग पहले जैसा ही है, और उपयोगकर्ता की आदतों को नहीं बदलना चाहिए या कोई समस्या नहीं होनी चाहिए।

\*इसे अन्य भाषाओं में पढ़ें:[अंग्रेज़ी](README_en.md),[सरलीकृत चीनी](README.md)

एपी एक शेल टूल है जो शेल कमांड के अन्य आउटपुट को इंटरेक्टिव मोड में स्वचालित रूप से फ़्लिप करने देता है।

एपी में दो भाग होते हैं, गो भाषा में लिखा गया एक बाइनरी प्रोग्राम, जो कमांड के आउटपुट को कैप्चर करने और पेज टर्निंग को सपोर्ट करने के लिए जिम्मेदार होता है,
और उपयोगकर्ता द्वारा निर्दिष्ट कमांड की सूची के लिए समान नाम का एक आवरण बनाने के लिए जिम्मेदार शेल स्क्रिप्ट का एक सेट।

रैप के बाद कमांड का उपयोग पहले जैसा ही है, इससे उपयोगकर्ता की परिचालन आदतों में बदलाव नहीं होना चाहिए, और इससे उपयोगकर्ता को परेशानी नहीं होगी।

## इंस्टॉल

    go install github.com/flw-cn/ap@master

## कॉन्फ़िगर

-   [दे घुमा के](#bash)
-   [मछली](#fish)
-   [ज़शो](#zsh)

### दे घुमा के

तुम्हारी ओर`~/.bashrc`इसमें निम्नलिखित जोड़ें:

```sh
eval "$(ap --bash)"
```

एपी डिफ़ॉल्ट रूप से आदेशों का एक बैच लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप इसे पर्यावरण चर के माध्यम से पुन: अनुकूलित कर सकते हैं:

```sh
AUTO_PAGER_CMDS=(go cargo make)
eval "$(ap --bash)"
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
AUTO_PAGER_CMDS_EXTRA=(ps last)
eval "$(ap --bash)"
```

इसके अलावा, एपी के साथ भी इस्तेमाल किया जा सकता है[जीआरसी](https://github.com/garabik/grc)एक साथ काम करते हुए, macOS के तहत Homebrew का उपयोग करके grc स्थापित किया जा सकता है:

```sh
brew install grc
```

एपी + जीआरसी डिफ़ॉल्ट रूप से कमांड के एक बैच को लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप इसे पर्यावरण चर के माध्यम से पुन: अनुकूलित कर सकते हैं:

```sh
AUTO_PAGER_CMDS_WITH_GRC=(ps last dig diff)
eval "$(ap --bash)"
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
AUTO_PAGER_CMDS_WITH_GRC_EXTRA=(ps last)
eval "$(ap --bash)"
```

इसके अलावा, पर्यावरण चर`$AUTO_PAGER_MIN_HEIGHT`आप पेजिंग शुरू करने के लिए लाइनों की न्यूनतम संख्या को नियंत्रित कर सकते हैं:

```sh
AUTO_PAGER_MIN_HEIGHT=30        # 输出超过 30 行时才开始分页
eval "$(ap --bash)"
```

यदि ऋणात्मक संख्या के रूप में कॉन्फ़िगर किया गया है, तो यह टर्मिनल विंडो की ऊंचाई के प्रतिशत का प्रतिनिधित्व करता है:

```sh
AUTO_PAGER_MIN_HEIGHT='-50'     # 输出超过终端窗口高度的 50% 时才开始分页
eval "$(ap --bash)"
```

यदि निर्दिष्ट नहीं है`AUTO_PAGER_MIN_HEIGHT`,डिफ़ॉल्ट है`-80`,अभी`80%`。

### मछली

तुम्हारी ओर`~/.config/fish/config.fish`इसमें निम्नलिखित जोड़ें:

```sh
ap --fish | source
```

एपी डिफ़ॉल्ट रूप से आदेशों का एक बैच लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप इसे पर्यावरण चर के माध्यम से पुन: अनुकूलित कर सकते हैं:

```sh
set AUTO_PAGER_CMDS go cargo make
ap --fish | source
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
set AUTO_PAGER_CMDS_EXTRA ps last
ap --fish | source
```

इसके अलावा, एपी के साथ भी इस्तेमाल किया जा सकता है[जीआरसी](https://github.com/garabik/grc)एक साथ काम करते हुए, macOS के तहत Homebrew का उपयोग करके grc स्थापित किया जा सकता है:

```sh
brew install grc
```

एपी + जीआरसी डिफ़ॉल्ट रूप से कमांड के एक बैच को लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप इसे पर्यावरण चर के माध्यम से पुन: अनुकूलित कर सकते हैं:

```sh
set AUTO_PAGER_CMDS_WITH_GRC ps last dig diff
ap --fish | source
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
set AUTO_PAGER_CMDS_WITH_GRC_EXTRA ps last
ap --fish | source
```

इसके अलावा, पर्यावरण चर`$AUTO_PAGER_MIN_HEIGHT`आप पेजिंग शुरू करने के लिए लाइनों की न्यूनतम संख्या को नियंत्रित कर सकते हैं:

```sh
set AUTO_PAGER_MIN_HEIGHT 30        # 输出超过 30 行时才开始分页
ap --fish | source
```

यदि ऋणात्मक संख्या के रूप में कॉन्फ़िगर किया गया है, तो यह टर्मिनल विंडो की ऊंचाई के प्रतिशत का प्रतिनिधित्व करता है:

```sh
set AUTO_PAGER_MIN_HEIGHT -50     # 输出超过终端窗口高度的 50% 时才开始分页
ap --fish | source
```

यदि निर्दिष्ट नहीं है`AUTO_PAGER_MIN_HEIGHT`,डिफ़ॉल्ट है`-80`,अभी`80%`。

### ज़शो

तुम्हारी ओर`~/.zshrc`इसमें निम्नलिखित जोड़ें:

```sh
eval "$(ap --zsh)"
```

एपी डिफ़ॉल्ट रूप से आदेशों का एक बैच लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप इसे पर्यावरण चर के माध्यम से पुन: अनुकूलित कर सकते हैं:

```sh
AUTO_PAGER_CMDS=(go cargo make)
eval "$(ap --zsh)"
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
AUTO_PAGER_CMDS_EXTRA=(ps last)
eval "$(ap --zsh)"
```

इसके अलावा, एपी के साथ भी इस्तेमाल किया जा सकता है[जीआरसी](https://github.com/garabik/grc)एक साथ काम करते हुए, macOS के तहत Homebrew का उपयोग करके grc स्थापित किया जा सकता है:

```sh
brew install grc
```

एपी + जीआरसी डिफ़ॉल्ट रूप से कमांड के एक बैच को लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप इसे पर्यावरण चर के माध्यम से पुन: अनुकूलित कर सकते हैं:

```sh
AUTO_PAGER_CMDS_WITH_GRC=(ps last dig diff)
eval "$(ap --zsh)"
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
AUTO_PAGER_CMDS_WITH_GRC_EXTRA=(ps last)
eval "$(ap --zsh)"
```

इसके अलावा, पर्यावरण चर`$AUTO_PAGER_MIN_HEIGHT`आप पेजिंग शुरू करने के लिए लाइनों की न्यूनतम संख्या को नियंत्रित कर सकते हैं:

```sh
AUTO_PAGER_MIN_HEIGHT=30        # 输出超过 30 行时才开始分页
eval "$(ap --zsh)"
```

यदि ऋणात्मक संख्या के रूप में कॉन्फ़िगर किया गया है, तो यह टर्मिनल विंडो की ऊंचाई के प्रतिशत का प्रतिनिधित्व करता है:

```sh
AUTO_PAGER_MIN_HEIGHT='-50'     # 输出超过终端窗口高度的 50% 时才开始分页
eval "$(ap --zsh)"
```

यदि निर्दिष्ट नहीं है`AUTO_PAGER_MIN_HEIGHT`,डिफ़ॉल्ट है`-80`,अभी`80%`。

## उपयोग

एपी रैप से गुजरने वाले कमांड को हमेशा की तरह इस्तेमाल करने की जरूरत है।
यदि बहुत अधिक आउटपुट है, तो पर्यावरण चर स्वचालित रूप से कॉल किया जाएगा`$PAGER`निर्दिष्ट पेजर पेजिनेशन करता है।

अगर आपका`$PAGER`चर विशेष हैं और उन्हें एपी के लिए अनुकूलित नहीं किया जा सकता है। आप पर्यावरण चर भी पारित कर सकते हैं`$AP_PAGER`एपी के लिए अलग से पेजर सेट करें।

अगर`$AP_PAGER`तथा`$PAGER`निर्दिष्ट नहीं हैं, तो उपयोग करेंगे`less -Fr`。

पेजर प्रारंभ नहीं होगा यदि:

-   जब आउटपुट सामग्री बहुत छोटी हो, तो देखें`$AUTO_PAGER_MIN_HEIGHT`。
-   जब एपी को पता चलता है कि कमांड आउटपुट में शामिल है`ESC [?1049h`अनुक्रम, आदेश एक पूर्ण-स्क्रीन अनुप्रयोग होने के लिए निर्धारित किया जाता है।
-   जब आदेश अभी तक निष्पादित नहीं किया गया है। पेजर तब तक शुरू नहीं होता जब तक कि कमांड का निष्पादन पूरा नहीं हो जाता।
    -   `ping`तथा`tcpdump`और इस तरह के अन्य कमांड, आपको प्रेस करने की आवश्यकता है`Ctrl-C`पेजिंग तब तक शुरू नहीं होता जब तक कि टर्मिनेट कमांड न हो।
    -   `python`तथा`gdb`इस तरह के कमांड को पेजिंग शुरू करने से पहले कमांड के बाहर निकलने का इंतजार करना पड़ता है।

## आम समस्या

-   क्या यह कमांड के रंगीन आउटपुट को प्रभावित करेगा?
    -   नहीं होगा।
-   कुछ कमांड है जो टर्मिनल का पता लगाता है और टर्मिनल मोड और गैर-टर्मिनल मोड के लिए अलग-अलग आउटपुट देता है, क्या यह अपना आउटपुट बदल देगा?
    -   नहीं होगा।
-   अगर मुझे संदेह है कि एपी कमांड के आउटपुट को प्रभावित कर रहा है तो मैं कैसे निदान कर सकता हूं?
    -   आप इसका उपयोग कर सकते हैं`command foo`अंजाम देना`foo`, ताकि एपी नहीं कहा जाता है।
-   अगर मैं आदतन कमांड को एपी कमांड में जोड़ देता हूं`| less`, कोई समस्या होगी?
    -   नहीं होगा।
-   क्या एपी कमांड अभी भी अपने आउटपुट को रीडायरेक्ट कर सकता है?
    -   कर सकना।
-   क्या एपी कमांड के लिए स्वत: पूर्णता टूट जाएगी?
    -   नहीं होगा।
-   एपी चीजों का समर्थन करता है जैसे`python`、`gdb`ऐसा इंटरैक्टिव एप्लिकेशन?
    -   सहयोग। लेकिन चूंकि ये ऐप्स कुछ कंट्रोल कैरेक्टर आउटपुट करते हैं, इसलिए पेजिंग के बाद आप जो कंटेंट देखते हैं वह थोड़ा गड़बड़ हो सकता है।
-   एपी चीजों का समर्थन करता है जैसे`htop`、`vim`इस तरह एक पूर्ण स्क्रीन ऐप?
    -   कैसे कहूं, वैसे भी गलत नहीं हो सकता, लेकिन मैं यह नहीं समझ सकता कि एपी को उनके साथ जोड़ने का व्यावहारिक बिंदु क्या है।
